<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Airplane Boarding Simulation</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden;
      background: #F0F0F0;
      font-family: sans-serif;
    }
    #gameContainer {
      width: 100%;
      height: 100%;
      position: relative;
    }
    #controls {
      position: absolute;
      top: 1rem;
      left: 1rem;
      padding: 0.5rem 0.75rem;
      background: rgba(255,255,255,0.85);
      border-radius: 6px;
      box-shadow: 0 0 6px rgba(0,0,0,0.2);
      z-index: 10;
    }
    .methodBtn {
      display: block;
      margin: 0.2rem 0;
      padding: 0.3rem 0.5rem;
      border: none;
      border-radius: 4px;
      background: #2b669a;
      color: white;
      cursor: pointer;
      width: 130px;
      text-align: left;
    }
    .methodBtn:hover {
      background: #3b7fad;
    }
    #startBtn, #clearBtn {
      display: block;
      margin-top: 0.5rem;
      padding: 0.5rem;
      border: none;
      border-radius: 4px;
      background: #0B6;
      color: white;
      cursor: pointer;
      width: 130px;
      text-align: center;
    }
    #startBtn:hover, #clearBtn:hover {
      background: #0D7;
    }
    #info {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      color: #333;
      min-height: 1.2rem;
    }
  </style>
</head>
<body>
<div id="gameContainer"></div>

<div id="controls">
  <strong>Boarding Method:</strong>
  <button class="methodBtn" id="btnFrontBack">Front to Back</button>
  <button class="methodBtn" id="btnBackFront">Back to Front</button>
  <button class="methodBtn" id="btnRandom">Random</button>
  <button class="methodBtn" id="btnWindowFirst">Window First</button>
  <button class="methodBtn" id="btnAisleFirst">Aisle First</button>
  <button class="methodBtn" id="btnOptimal">Optimal</button>

  <button id="startBtn">Start Boarding</button>
  <button id="clearBtn">Clear Boarding</button>
  <div id="info"></div>
</div>

<script>
/*
  Phaser 3 - Realistic Airplane Boarding
  Requirements addressed:
  - 10 rows, 4 seats (A,B | aisle | C,D)
  - "Top-down" plane with center aisle
  - No seat overlap (they walk in the aisle, then step into seat)
  - Basic passenger collision (they queue if one is too close)
  - Timer & final message at bottom-left
  - Clear boarding button
  - Colored & labeled passengers so you know each seat assignment
*/

/* =============== PASSENGER CLASS =============== */
class Passenger {
  constructor(scene, seatLabel, seatObj, spawnX, spawnY, color){
    this.scene = scene;
    this.seatLabel = seatLabel;
    this.inSeat = false;
    this.x = spawnX;
    this.y = spawnY;
    this.radius = 10;
    this.speed = 1.6; // movement speed in px/step
    this.seatObj = seatObj; // { row, col, x, y, w, h }
    this.color = color;

    // Create the circle
    this.circle = scene.add.circle(this.x, this.y, this.radius, this.color);
    // Outline
    this.circle.setStrokeStyle(2, 0x000000);

    // Create the seat label text above the passenger
    this.labelText = scene.add.text(this.x - 12, this.y - 28, seatLabel, {
      font: "14px Arial",
      fill: "#000"
    });
    // For legibility, consider a small background or stroke
    // But let's keep it simple

    // We'll define a route of up to 3-4 points:
    // 1) Move down to row's aisleY
    // 2) Move horizontally to seat center X
    // 3) Move a small vertical offset to seat center Y
    // We'll do it step by step in update()
    this.route = [];
    this.routeIndex = 0;
    this.buildRoute();
  }

  buildRoute(){
    // The row's aisle Y
    const rowAisleY = this.scene.rowData.find(r => r.row === this.seatObj.row)?.aisleY || this.seatObj.y+(this.seatObj.h/2);

    // Step 1: Move down from spawn to row's aisleY (same x, different y)
    this.route.push({ x: this.x, y: rowAisleY });

    // Step 2: Move horizontally to seat center X
    this.route.push({ x: this.seatObj.x + this.seatObj.w/2, y: rowAisleY });

    // Step 3: Move vertically to seat center Y
    this.route.push({ x: this.seatObj.x + this.seatObj.w/2, y: this.seatObj.y + this.seatObj.h/2 });
  }

  update(passengers){
    if(this.inSeat) return;
    if(this.routeIndex >= this.route.length){
      // done
      this.inSeat = true;
      // change stroke color to indicate seated
      this.circle.setStrokeStyle(2, 0xffffff);
      return;
    }

    // The next point
    const pt = this.route[this.routeIndex];
    let dx = pt.x - this.x;
    let dy = pt.y - this.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if(dist < this.speed){
      // close enough => snap
      this.x = pt.x;
      this.y = pt.y;
      this.updatePosition();
      this.routeIndex++;
      if(this.routeIndex >= this.route.length){
        this.inSeat = true;
        this.circle.setStrokeStyle(2, 0xffffff);
      }
      return;
    }
    // otherwise move step
    dx /= dist;
    dy /= dist;
    const nextX = this.x + dx*this.speed;
    const nextY = this.y + dy*this.speed;

    // Collision check with other passengers
    // If nextX, nextY is too close to any occupant in front, we do not move
    // We'll define "in front" => all passengers who have routeIndex <= ours
    // or just check every passenger who hasn't finished
    for(let p of passengers){
      if(p === this || p.inSeat) continue;
      const ddx = p.x - nextX;
      const ddy = p.y - nextY;
      const ddist = Math.sqrt(ddx*ddx + ddy*ddy);
      if(ddist < (this.radius*2.5)){ 
        // ~2.5*r => about 25 px
        // if too close, skip movement => "queue"
        return;
      }
    }

    // If no collision, commit the move
    this.x = nextX;
    this.y = nextY;
    this.updatePosition();
  }

  updatePosition(){
    this.circle.x = this.x;
    this.circle.y = this.y;
    this.labelText.x = this.x - 12;
    this.labelText.y = this.y - 28;
  }

  destroy(){
    this.circle.destroy();
    this.labelText.destroy();
  }
}

/* =============== BOARDING SCENE =============== */
class BoardingScene extends Phaser.Scene {
  constructor(){
    super("BoardingScene");
  }

  init(){
    this.selectedMethod = "front-back";
    this.simulationRunning = false;
    this.boardingFinished = false;
    this.startTime = 0;
    this.endTime = 0;

    this.seats = [];      // seat objects
    this.rowData = [];    // each row => { row, aisleY }
    this.passengers = []; // active passenger objects
  }

  preload(){
    // no external assets
  }

  create(){
    // 1) Build plane geometry
    this.createPlane();

    // 2) Build seats
    this.buildSeats();

    // 3) Build row data (center aisle lines)
    this.buildRowData();

    // Info text at bottom left
    this.infoText = this.add.text(20, 560, "Ready...", {
      font: "18px Arial",
      fill: "#333"
    }).setDepth(999);

    // Hook up method buttons
    document.getElementById("btnFrontBack").onclick  = ()=>{this.selectedMethod="front-back";this.updateInfo();};
    document.getElementById("btnBackFront").onclick  = ()=>{this.selectedMethod="back-front";this.updateInfo();};
    document.getElementById("btnRandom").onclick     = ()=>{this.selectedMethod="random";this.updateInfo();};
    document.getElementById("btnWindowFirst").onclick= ()=>{this.selectedMethod="window-first";this.updateInfo();};
    document.getElementById("btnAisleFirst").onclick = ()=>{this.selectedMethod="aisle-first";this.updateInfo();};
    document.getElementById("btnOptimal").onclick    = ()=>{this.selectedMethod="optimal";this.updateInfo();};

    // Start & Clear buttons
    document.getElementById("startBtn").onclick = ()=>{
      if(!this.simulationRunning){
        this.startBoarding();
      }
    };
    document.getElementById("clearBtn").onclick = ()=>{
      this.clearBoarding();
    };

    this.updateInfo();
  }

  update(time, delta){
    if(this.simulationRunning && !this.boardingFinished){
      // update each passenger
      let notSeatedCount = 0;
      for(let p of this.passengers){
        if(!p.inSeat){
          p.update(this.passengers);
          notSeatedCount++;
        }
      }
      if(notSeatedCount===0){
        this.boardingFinished = true;
        this.endTime = performance.now();
        const totalSec = ((this.endTime - this.startTime)/1000).toFixed(2);
        this.infoText.setText(`All seated! Time: ${totalSec}s, Method: ${this.selectedMethod}`);
      }
    }
  }

  updateInfo(){
    let text = `Method: ${this.selectedMethod}`;
    this.infoText.setText(text);
    document.getElementById("info").textContent = text;
  }

  /* ========== 1) CREATE PLANE GEOMETRY (TOP-DOWN) ========== */
  createPlane(){
    // We'll define the plane to fit a 1000x600 area:
    // cockpit at top, tail at bottom, wings to the sides
    this.planeRect = { x: 200, y: 50, w: 600, h: 450 };

    // Fuselage rectangle
    const fuselageG = this.add.graphics({ 
      lineStyle: { width:4, color:0xB3C4C1 }, 
      fillStyle: { color:0xE5FFFB } 
    });
    fuselageG.fillRect(this.planeRect.x, this.planeRect.y, this.planeRect.w, this.planeRect.h);
    fuselageG.strokeRect(this.planeRect.x, this.planeRect.y, this.planeRect.w, this.planeRect.h);

    // Cockpit (triangle at top center)
    const cockpitG = this.add.graphics({ fillStyle:{ color: 0xCCEFEA }});
    cockpitG.fillTriangle(
      this.planeRect.x + this.planeRect.w/2, this.planeRect.y - 40,
      this.planeRect.x + this.planeRect.w/2 - 40, this.planeRect.y,
      this.planeRect.x + this.planeRect.w/2 + 40, this.planeRect.y
    );

    // Wings (left & right)
    const wingG = this.add.graphics({ fillStyle:{ color:0xCCEFEA } });
    const midY = this.planeRect.y + this.planeRect.h/2;
    // left wing
    wingG.fillTriangle(
      this.planeRect.x, midY,
      this.planeRect.x - 80, midY - 60,
      this.planeRect.x - 80, midY + 60
    );
    // right wing
    wingG.fillTriangle(
      this.planeRect.x + this.planeRect.w, midY,
      this.planeRect.x + this.planeRect.w + 80, midY - 60,
      this.planeRect.x + this.planeRect.w + 80, midY + 60
    );

    // Tail rectangle
    const tailG = this.add.graphics({ fillStyle:{ color:0xCCEFEA }});
    tailG.fillRect(
      this.planeRect.x + this.planeRect.w/2 - 30,
      this.planeRect.y + this.planeRect.h,
      60, 40
    );
  }

  /* ========== 2) BUILD SEATS ========== */
  buildSeats(){
    // We'll have 10 rows, each with 4 seats: A,B (left), C,D (right) with a center aisle
    // The top row is row=1 near planeRect.y+30, bottom row=10 near planeRect.y+planeRect.h-80
    const rowCount = 10;
    const topMargin = this.planeRect.y + 30;
    const bottomMargin = this.planeRect.y + this.planeRect.h - 80;
    const totalH = (bottomMargin - topMargin);
    const rowGap = totalH / rowCount;

    // We'll define seat size
    const seatW = 40, seatH = 30;
    // We'll define a center aisle => left seats from x=planeRect.x+50 to x=planeRect.x+180, right seats from x=planeRect.x+380 to x=planeRect.x+510
    // That leaves a gap in the center
    const leftSeatX   = this.planeRect.x + 80;  // A
    const leftSeatX2  = this.planeRect.x + 130; // B
    const rightSeatX  = this.planeRect.x + 390; // C
    const rightSeatX2 = this.planeRect.x + 440; // D

    const COLS = ["A","B","C","D"];

    for(let r=1; r<=rowCount; r++){
      const seatY = topMargin + (r-1)*rowGap;
      // Left seats A,B
      const ab = [
        { col:"A", x:leftSeatX,   y:seatY },
        { col:"B", x:leftSeatX2,  y:seatY }
      ];
      // Right seats C,D
      const cd = [
        { col:"C", x:rightSeatX,  y:seatY },
        { col:"D", x:rightSeatX2, y:seatY }
      ];
      const rowSeats = [...ab, ...cd];
      rowSeats.forEach((sobj, i)=>{
        const label = `${r}${sobj.col}`;
        this.drawSeat(sobj.x, sobj.y, seatW, seatH, label);
      });
    }
  }

  drawSeat(x, y, w, h, label){
    // store seat data
    const rowNum = parseInt(label);
    const col = label.replace(/^\d+/,"");
    // seat rectangle
    let g = this.add.graphics({ lineStyle:{ width:2, color:0x99A3F2 }, fillStyle:{ color:0x000080 } });
    g.fillRect(x, y, w, h);
    g.strokeRect(x, y, w, h);
    // text
    this.add.text(x+4, y+8, label, { font:"14px Arial", fill:"#FFF" });
    this.seats.push({
      label, row:rowNum, col,
      x, y, w, h
    });
  }

  /* ========== 3) BUILD ROW DATA (AISLE Y) ========== */
  buildRowData(){
    // For each row, define an aisleY => roughly the seat center
    // We'll just pick seat "B" or "C" as a reference
    let uniqueRows = [...new Set(this.seats.map(s=>s.row))].sort((a,b)=>a-b);
    uniqueRows.forEach(r=>{
      const rowSeats = this.seats.filter(s=>s.row===r);
      // pick the average center y
      const avgY = rowSeats.reduce((acc,v)=> acc+(v.y+v.h/2), 0)/rowSeats.length;
      this.rowData.push({ row:r, aisleY: avgY });
    });
  }

  /* ========== START BOARDING ========== */
  startBoarding(){
    this.simulationRunning = true;
    this.boardingFinished = false;
    this.startTime = performance.now();
    this.infoText.setText(`Boarding started... Method: ${this.selectedMethod}`);

    // reorder seats
    let seatLabels = this.seats.map(s=>s.label);
    seatLabels = this.reorderSeats(seatLabels, this.selectedMethod);

    // spawn them from top center
    // top center: x=planeRect.x + planeRect.w/2, y=planeRect.y - 30
    const spawnX = this.planeRect.x + this.planeRect.w/2;
    const spawnY = this.planeRect.y - 30;

    seatLabels.forEach((lbl, i)=>{
      this.time.delayedCall(i*400, ()=>{
        // find seat
        const seatObj = this.seats.find(s=>s.label===lbl);
        // color code by col
        let color = 0xDDDDDD;
        switch(seatObj.col){
          case "A": color=0x008080; break; // teal
          case "B": color=0x0000A0; break; // darkblue
          case "C": color=0x800080; break; // purple
          case "D": color=0xAA0000; break; // red
        }
        const passenger = new Passenger(this, lbl, seatObj, spawnX, spawnY, color);
        this.passengers.push(passenger);
      });
    });
  }

  /* ========== CLEAR BOARDING ========== */
  clearBoarding(){
    this.simulationRunning = false;
    this.boardingFinished = false;
    this.infoText.setText("Boarding cleared. Pick method & start again.");
    // destroy all passengers
    this.passengers.forEach(p => p.destroy());
    this.passengers = [];
  }

  /* ========== REORDER SEATS ACCORDING TO METHOD ========== */
  reorderSeats(list, method){
    let arr = list.map(lbl=>{
      return {
        label: lbl,
        row: parseInt(lbl),
        col: lbl.replace(/^\d+/,"")
      };
    });
    const windowOrder = { "A":1, "D":2, "B":3, "C":4 };
    const aisleOrder = { "B":1, "C":2, "A":3, "D":4 };

    switch(method){
      case "front-back":
        arr.sort((a,b)=> (a.row-b.row)||(a.col.localeCompare(b.col)));
        break;
      case "back-front":
        arr.sort((a,b)=> (b.row-a.row)||(a.col.localeCompare(b.col)));
        break;
      case "random":
        for(let i=arr.length-1;i>0;i--){
          const j = Phaser.Math.Between(0,i);
          [arr[i], arr[j]]=[arr[j], arr[i]];
        }
        break;
      case "window-first":
        arr.sort((a,b)=>{
          if(a.row!==b.row) return a.row-b.row;
          return windowOrder[a.col] - windowOrder[b.col];
        });
        break;
      case "aisle-first":
        arr.sort((a,b)=>{
          if(a.row!==b.row) return a.row-b.row;
          return aisleOrder[a.col] - aisleOrder[b.col];
        });
        break;
      case "optimal":
        // placeholder => back-front & window-first
        arr.sort((a,b)=>{
          if(a.row!==b.row) return b.row-a.row; // back->front
          return windowOrder[a.col] - windowOrder[b.col]; // window first
        });
        break;
      default:
        arr.sort((a,b)=> (a.row-b.row)||(a.col.localeCompare(b.col)));
    }

    return arr.map(o=>o.label);
  }
}

/* ========== CREATE GAME ========== */
const config = {
  type: Phaser.AUTO,
  width: 1000,
  height: 600,
  backgroundColor: "#F0F0F0",
  parent: "gameContainer",
  scene: [ BoardingScene ]
};

new Phaser.Game(config);
</script>
</body>
</html>
